{
  "name": "export-from-json",
  "version": "1.7.2",
  "description": "Export to txt, json, csv, xls, xml format file from valid JavaScript JSON object.",
  "keywords": [
    "json",
    "csv",
    "xls",
    "xml",
    "excel",
    "typescript"
  ],
  "type": "module",
  "main": "dist/umd/index.js",
  "module": "dist/esm/index.js",
  "typings": "dist/types/index.d.ts",
  "repository": "https://github.com/zheeeng/export-from-json",
  "author": "Zheeeng",
  "license": "MIT",
  "files": [
    "src",
    "dist",
    "example"
  ],
  "exports": {
    ".": {
      "require": "./dist/umd/index.js",
      "types": "./dist/types/index.d.ts",
      "default": "./dist/esm/index.js"
    },
    "./package.json": "./package.json"
  },
  "devDependencies": {
    "@types/jest": "^29.0.0",
    "husky": "^8.0.0",
    "jest": "^29.0.0",
    "rollup": "^3.0.0",
    "rollup-plugin-typescript2": "^0.34.0",
    "rollup-plugin-uglify": "^6.0.4",
    "ts-jest": "^29.0.0",
    "tslib": "^2.3.1",
    "tslint": "^6.1.3",
    "typescript": "^4.6.2"
  },
  "jest": {
    "extensionsToTreatAsEsm": [
      ".ts"
    ],
    "moduleNameMapper": {
      "^(\\.{1,2}/.*)\\.js$": "$1"
    },
    "transform": {
      "^.+\\.ts$": [
        "ts-jest",
        {
          "useESM": true
        }
      ]
    },
    "testRegex": "/__tests__/.+\\.spec.ts$",
    "moduleFileExtensions": [
      "js",
      "ts"
    ]
  },
  "scripts": {
    "prebuild": "rm -rf dist",
    "dev": "rollup -w -c ./config/rollup.config.js",
    "build": "npm run build:esm && npm run build:es2015 && npm run build:umd",
    "build:es2015": "tsc -p ./config/tsconfig.es2015.json",
    "build:esm": "tsc -p ./config/tsconfig.esm.json",
    "build:umd": "rollup -c ./config/rollup.config.js",
    "test": "npm run test:lint && npm run test:spec",
    "test:spec": "jest",
    "test:update": "jest --updateSnapshot",
    "test:lint": "tslint -p ./tsconfig.json",
    "test:manual": "npm test && npm run build && open example/index.html",
    "precommit": "npm test",
    "prepush": "npm test",
    "release": "npm version patch && npm publish"
  },
  "readme": "<h1 align=\"center\">Export From JSON</h1>\n\n<div align=\"center\">\n\nExport to plain text, css, html, json, csv, xls, xml files from JSON.\n\n[![Known Vulnerabilities](https://snyk.io/test/github/zheeeng/export-from-json/badge.svg)](https://snyk.io/test/github/zheeeng/export-from-json)\n[![Maintainability](https://api.codeclimate.com/v1/badges/2fbc35f65ba61bc190e1/maintainability)](https://codeclimate.com/github/zheeeng/export-from-json/maintainability)\n[![language](https://img.shields.io/badge/%3C%2F%3E-TypeScript-blue.svg)](http://typescriptlang.org/)\n[![license](https://img.shields.io/github/license/mashape/apistatus.svg)](https://github.com/zheeeng/export-from-json/blob/main/LICENSE)\n[![Build Status](https://travis-ci.org/zheeeng/export-from-json.svg?branch=main)](https://travis-ci.org/zheeeng/export-from-json)\n[![npm version](https://img.shields.io/npm/v/export-from-json.svg)](https://www.npmjs.com/package/export-from-json)\n[![npm bundle size (minified + gzip)](https://img.shields.io/bundlephobia/minzip/export-from-json.svg)](https://unpkg.com/export-from-json/dist/umd/index.min.js)\n[![NPM](https://nodei.co/npm/export-from-json.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/export-from-json/)\n\n</div>\n\n## Installation\n\n```sh\nyarn add export-from-json\n```\n\nor\n\n```sh\nnpm i --save export-from-json\n```\n\nor\n\n```sh\npnpm i --save export-from-json\n```\n\n## Usage\n\n`exportFromJSON` supports CommonJS, EcmaScript Module, UMD importing.\n\n`exportFromJSON` receives the option as the [Types Chapter](#types) demonstrated, and it uses a [front-end downloader](https://github.com/zheeeng/export-from-json/blob/main/src/processors.ts) as the default processor. In browser environment, there is a **content size limitation** on the default processor, consider using the [server side solution](#in-nodejs-server).\n\n### In module system\n\n```javascript\nimport exportFromJSON from 'export-from-json'\n\nconst data = [{ foo: 'foo'}, { bar: 'bar' }]\nconst fileName = 'download'\nconst exportType =  exportFromJSON.types.csv\n\nexportFromJSON({ data, fileName, exportType })\n```\n\n### In browser\n\nCheck the [codepen example](https://codepen.io/zheeeng/pen/PQxBKr)\n\n```javascript\n<script src=\"https://unpkg.com/export-from-json/dist/umd/index.min.js\"></script>\n<script>\n    const data = [{ foo: 'foo'}, { bar: 'bar' }]\n    const fileName = 'download'\n    const exportType = 'csv'\n\n    window.exportFromJSON({ data, fileName, exportType })\n</script>\n```\n\n### In Node.js server\n\n`exportFromJSON` returns what the option `processor` returns, we can use it on server side for providing a converting/downloading service:\n\n```javascript\nconst http = require('http')\nconst exportFromJSON = require('export-from-json')\n\nhttp.createServer(function (request, response){\n    // exportFromJSON actually supports passing JSON as the data option. It's very common that reading it from http request directly.\n    const data = '[{\"foo\":\"foo\"},{\"bar\":\"bar\"}]'\n    const fileName = 'download'\n    const exportType = 'txt'\n\n    const result = exportFromJSON({\n        data,\n        fileName,\n        exportType,\n        processor (content, type, fileName) {\n            switch (type) {\n                case 'txt':\n                    response.setHeader('Content-Type', 'text/plain')\n                    break\n                case 'css':\n                    response.setHeader('Content-Type', 'text/css')\n                    break\n                case 'html':\n                    response.setHeader('Content-Type', 'text/html')\n                    break\n                case 'json':\n                    response.setHeader('Content-Type', 'text/plain')\n                    break\n                case 'csv':\n                    response.setHeader('Content-Type', 'text/csv')\n                    break\n                case 'xls':\n                    response.setHeader('Content-Type', 'application/vnd.ms-excel')\n                    break\n            }\n            response.setHeader('Content-disposition', 'attachment;filename=' + fileName)\n            return content\n        }\n    })\n\n    response.write(result)\n    response.end()\n}).listen(8080, '127.0.0.1')\n```\n\n## Types\n\n**Note:** `JSON` refers to a parsable JSON string or a serializable JavaScript object.\n\n| Option name | Required | Type | Description\n| ----------- | -------- | ---- | ----\n| data        | true     | `Array<JSON>`, `JSON` or `string` | If the exportType is 'json', data can be any parsable JSON. If the exportType is 'csv' or 'xls', data can only be an array of parsable JSON.  If the exportType is 'txt', 'css', 'html', the data must be a string type.\n| fileName    | false    | string | filename without extension, default to `'download'`\n| extension    | false    | string | filename extension, by default it takes the exportType\n| fileNameFormatter    | false    | `(name: string) => string` | filename formatter, by default the file name will be formatted to snake case\n| fields      | false    | `string[]` or field name mapper type `Record<string, string>`  | fields filter, also supports mapper field name by passing an name mapper, e.g. { 'bar': 'baz' }, default to `undefined`\n| exportType  | false    | Enum ExportType | 'txt'(default), 'css', 'html', 'json', 'csv', 'xls', 'xml'\n| processor   | false    | `(content: string, type: ExportType, fileName: string) => any` | default to a front-end downloader\n| withBOM     | false    | boolean | Add BOM(byte order mark) meta to CSV file. BOM is expected by `Excel` when reading UTF8 CSV file. It is default to `false`.\n| beforeTableEncode     | false    | `(entries: { fieldName: string, fieldValues: string[] }[]) => { fieldName: string, fieldValues: string[] }[]` | Given a chance to altering table entries, only works for `CSV` and `XLS` file, by default no altering.\n| delimiter   | false    | `',' | ';'` | Specify CSV raw data's delimiter between values.\n\n### Tips\n\n* You can reference these exported types through a mounted static field `types`, e.g.\n\n```js\nexportFromJSON({ data: jsonData, fileName: 'data', exportType: exportFromJSON.types.csv })\n```\n\n* You can transform the data before exporting by `beforeTableEncode`, e.g.\n\n```js\nexportFromJSON({\n    data: jsonData,\n    fileName: 'data',\n    exportType: exportFromJSON.types.csv,\n    beforeTableEncode: rows => rows.sort((p, c) => p.fieldName.localeCompare(c.fieldName)),\n})\n```\n"
}