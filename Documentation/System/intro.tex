\chapter{Introduction}
\ac{RAILS} is a software model and implementation of an automated system to assist the model railroader achieve realism in the operation of a model railroad. The model then drives the development of hardware and or software.
The system provides, but not limited to the following functions:
\begin{itemize}
  \item planing operating session resulting from the needs of industries to move products from one location to another
  \item simulating rolling stock failures
  \item controlling trains
  \item automating regular scheduled trains 
  \item displaying the rail network and location of trains.
\end{itemize}
In addition, it provides:
\begin{itemize}
  \item model railroad asset tracking and management by organizing the development of assets into projects
  \item rolling stock inventory
  \item reports
\end{itemize} 
The system interacts with several key electronic subsystems to control the physical model railroad environment.
\section{Original Approach}
The original approach that was taken was use a standard software development methodology, starting with the development of requirements through the use of use-cases. The initial client/server design pattern was based on using:
\begin{itemize}
\item \ac{JEE}, which is a collection of Java technologies and standards for building enterprise applications. \ac{JEE} applications are typically monolithic, meaning that all of the components of the application are packaged together and deployed as a single unit. They can be developed using various Java frameworks such as Spring, \ac{JSF}, and \ac{EJB}, and they are typically deployed to an application server such as Apache Tomcat or Oracle WebLogic.
\item \ac{RDB}, which is a type of database that stores data in the form of related tables. These tables have rows and columns, and each row represents a single record, while each column represents a specific field of data. The tables are related to each other through the use of common fields, known as keys, which are used to link the data in different tables together. This allows for efficient querying and data manipulation. Examples of relational databases include MySQL, SQL Server, DB2, and Oracle.
\end{itemize}
The result would be a web application that would provide multiple users access to the developed system.\vspace{5mm} \\
That approach was undertaken almost two decades ago and based on expertise at hand. Since technology evolved and more options were made available the focus switched from Java to JavaScript and from a relational database to non-relational database. The use cases were still relevant as they speak to the user interactions with the system.
\section{Approach Implemented}
The revised client/server design pattern that is being implemented is based on using:
\begin{itemize}
\item Node.js is a JavaScript run-time built on Chrome's V8 JavaScript engine. It allows developers to run JavaScript on the server-side, and is commonly used for building web servers and APIs. Node.js is typically used to handle the server-side functionality.
For more information about Node.js, visit the \href{https://nodejs.org/}{official website}.
\item Vue.js is a JavaScript framework for building user interfaces. It is similar to other popular JavaScript frameworks such as React and Angular, but is often considered more lightweight and easy to learn. Vue.js allows developers to create reusable \ac{UI} components and manage the state of the application. Vue.js is used to handle the client-side functionality.
For more information about Vue.js, visit the \href{https://vuejs.org/}{official website}.
\item MongoDB, referred to as a non-relational or NoSQL database. It is a type of database that does not use the traditional table-based relational model. Instead, it uses a flexible schema model that allows for the storage of data in a variety of formats, such as key-value pairs, document-based, graph-based, or object-based.
For more information about MongoDB, visit the \href{https://www.mongodb.com/}{official website}.
\end{itemize}
\subsection{Architecture}
Moving from a monolithic \ac{JEE} application to a distributed set of components requires a different architecture design pattern. One such pattern is microservices architecture. The microservices architectural style is an evolution of the \ac{SOA} architectural style.\vspace{5mm} \\
It is a method of developing software applications in which a large application is built as a collection of small, independent services. These services communicate with each other through APIs, and each service can be developed, deployed, and scaled independently of the others. Microservices are often deployed in containerized environments and use technologies such as Kubernetes to manage and orchestrate the services. Microservices offers several advantages over monolithic architectures such as:
\begin{itemize}
\item Scalability: Each service can be scaled independently, so it's easy to add more resources to a specific service that's experiencing heavy load.
\item Resilience: Because each service is isolated, a failure in one service will not bring down the entire application.
\item Flexibility: Services can be written in different languages, which makes it easy to use the best tool for the job.
\item Ease of Deployment: Since each service can be deployed independently, the deployment process can be simplified.
\end{itemize}
\subsection{Technologies}
In designing and implementing \ac{RAILS} several technologies have been added to microservices architectural style that compliment it. They are:
\subsubsection{Docker}
In the context of microservices, containers are used to package the code, libraries, and configuration files needed for a microservice to run as a single, executable unit. This makes it easy to deploy and run microservices in different environments, such as on-premises servers or in the cloud. By packaging all the dependencies for a microservice in a container, it can be guaranteed to run the same way regardless of the environment it's deployed in. This helps to reduce issues caused by differences between development, testing, and production environments. Containers also make it easy to scale up or down the number of instances of a microservice running, and to update or rollback a microservice without affecting other services.\vspace{5mm} \\
Docker is a platform that makes it easy to create, deploy, and run applications in containers. It provides a \ac{CLI} and a set of \acp{API} that make it simple to work with containers. Docker in conjunction with microservices is used to package and deploy each service in its own container. This allows each service to be managed, deployed, and scaled independently of other services. The Docker platform provides a number of tools to help manage and orchestrate the containers that make up a microservice-based application, such as Docker Compose and Docker Swarm.\vspace{5mm} \\
Docker is an open-source platform that enables developers to automate the deployment, scaling, and management of applications using containerization. Containers are lightweight, isolated environments that encapsulate an application and all its dependencies, including libraries, frameworks, and other runtime components. Docker allows the user to package an application into a container image, which can then be run consistently across different environments, such as development, testing, and production.\vspace{5mm} \\
Docker provides the following features:
\begin{itemize}
  \item Docker containers are portable and can run on any system that supports Docker, regardless of the underlying operating system or infrastructure. This eliminates the "works on my machine" problem and ensures consistent behavior across different environments.
  \item Containers provide a high level of isolation, ensuring that applications and their dependencies are encapsulated and do not interfere with each other. This isolation improves security, as well as prevents conflicts between different software components.
  \item Docker containers are lightweight and share the host system's operating system kernel. This means they require fewer resources compared to traditional virtual machines (VMs). Multiple containers can run on the same host without significant performance overhead.
  \item Docker makes it easy to scale applications horizontally by running multiple instances of containers across different hosts or a cluster of machines. This enables efficient utilization of resources and helps handle increased workload demands.
  \item Docker allows versioning of container images, making it easier to track changes and roll back to a previous version if needed. This simplifies the deployment and update process, reducing the risk of application downtime.
  \item Docker has a large and active community, resulting in a vast ecosystem of pre-built container images available from Docker Hub and other registries. These images can be easily pulled and used as a base for building and deploying applications, saving development time.
\end{itemize}
For additional information on Docker see the \href{https://www.docker.com/}{official website}.
\subsubsection{Git \& GitHub}
Git is a distributed \ac{VCS} used for tracking changes in source code during software development. It was created by Linus Torvalds, the creator of the Linux operating system, in 2005. Git allows multiple developers to collaborate on a project by providing a mechanism to manage and merge their code changes efficiently.\vspace{5mm} \\
GitHub is a web-based hosting service and collaboration platform for Git repositories. It provides a centralized location where developers can store, manage, and collaborate on their Git repositories. GitHub offers a variety of features and tools that enhance the functionality of Git and facilitate collaboration among developers and teams.\vspace{5mm} \\
Microsoft acquired GitHub in June 2018 in a deal worth \$7.5 billion. Following the acquisition, GitHub continues to operate as an independent platform, maintaining its brand, services, and user base while also benefiting from Microsoft's resources and support.\vspace{5mm} \\
GitHub provides the following features:
\begin{itemize}
  \item GitHub allows users to host their Git repositories on its servers. Developers can create repositories to store their code and version history.
  \item GitHub promotes social collaboration and networking among developers. Users can follow other developers, star and fork repositories, and contribute to open-source projects.
  \item GitHub includes an issue tracking system where users can create, assign, and track issues related to their projects. Issues can be used to report bugs, suggest enhancements, or discuss project-related topics.
  \item GitHub provides features such as wikis, project boards, and discussions to help teams collaborate effectively. Wikis allow for documentation and knowledge sharing, project boards help manage tasks and workflows, and discussions provide a platform for team communication.
  \item GitHub Pages is a feature that enables users to host static websites directly from their repositories. It simplifies the process of publishing and sharing web content.
\end{itemize}
GitHub offers both free and paid plans, with additional features and storage available in the paid tiers. It has become a popular choice for individual developers, open-source projects, and large organizations due to its user-friendly interface, strong community, and extensive features for code collaboration and project management.
For additional information on Git see the \href{https://git-scm.com/}{official website}.
\subsubsection{IoT}
\ac{IoT} refers to the network of physical devices, vehicles, buildings, and other items embedded with electronics, software, sensors, and connectivity which enables these objects to connect and exchange data.
\subsubsection{MQTT}
\ac{MQTT} is a lightweight publish-subscribe messaging protocol that is commonly used for communication in \ac{IoT} systems. It enables devices to send and receive messages over a network in a decentralized and efficient way. \ac{MQTT} is often used in \ac{IoT} because it is lightweight and requires minimal network bandwidth, making it well-suited for use on resource-constrained devices and low-bandwidth networks. Equally as important there a multiple implementations of the open source client software that are available for microcontrollers such as TI-Tiva, Arduino and Raspberry PI. The following are the high level features:
\begin{itemize}
\item Publish/subscribe: The \ac{MQTT} protocol is based on the principle of publishing messages and subscribing to topics, which is typically referred to as a publish/subscribe model or sometimes abbreviated to pub/sub. Clients can subscribe to topics that are relevant to them. Then those clients only receive messages that are published to those topics. Alternatively, clients can publish messages to topics, which in turn makes them available to all subscribers of those topics.
\item Quality of service levels: \ac{MQTT} defines three \ac{QoS} levels for message delivery, with each level providing a higher level of assurance the message gets delivered. However higher \ac{QoS} levels are likely to consume more network bandwidth or subject the message to delays.
\item Retained messages: With \ac{MQTT}, the server keeps the message even after sending it to all current subscribers. If a new subscription is submitted for the same topic, any retained messages are then sent to the new subscribing client.
\item Clean sessions and durable connections: When an \ac{MQTT} client connects to the server, it sets the clean session flag. If the flag is set to true, all of the client’s subscriptions are removed when it disconnects from the server. If the flag is set to false, the connection is treated as durable, and the client’s subscriptions remain in effect after any disconnection. In this event, subsequent messages that arrive carrying a high \ac{QoS} designation are stored for delivery after the connection is reestablished. Using the clean session flag is optional.
\item Wills: When a client connects to a server, it can inform the server that it has a will , or a message, that should be published to a specific topic or topics in the event of an unexpected disconnection. A will is particularly useful in alarm or security settings where system managers must know immediately when a remote sensor has lost contact with the network.
\end{itemize}
A detailed explantion of the basics of MQTT can be found in the \href{https://www.hivemq.com/mqtt-essentials/}{MQTT Essentials} guide.
\subsubsection{Microcontoller}
A microcontroller is a small computer on a single integrated circuit that contains a processor core, memory, and programmable input/output peripherals. It is designed to control a specific function or set of functions within a larger system. Microcontrollers are used in a wide range of electronic devices and appliances, including automobiles, appliances, and consumer electronics.
There are multiple advantages to using microcontrollers in electronic devices and systems:
\begin{itemize}
\item Cost-effective: Microcontrollers are relatively inexpensive and can be used to control a wide range of functions in a single device, reducing the overall cost of the system.
\item Low power consumption: Microcontrollers are designed to consume minimal power, which makes them well-suited for use in battery-powered or low-power applications.
\item Compact size: Microcontrollers are small in size, which allows them to be used in tight spaces or portable devices.
\item Flexibility: Microcontrollers can be easily programmed to perform a wide range of functions, making them highly versatile and adaptable to different applications.
\item Easy to interface with other devices: Microcontrollers have a variety of \ac{I/O} ports, which makes it easy to interface them with other devices such as sensors, actuators, and communication interfaces.
\item Real-time performance: Microcontrollers can perform a variety of tasks concurrently, and also can handle real-time events which allows them to respond quickly to changing conditions in the system.
\item Robustness: Microcontrollers are designed to operate in a wide range of environments, and can be used in harsh conditions like extreme temperatures and high levels of radiation.
\end{itemize}
In the context of the \ac{IoT}, microcontrollers are used to collect data from sensors and control actuators, and to process and transmit that data over a network.
\section{Software Development}
Microservices development is a software development approach in which a software application is broken down into smaller, independent services that can be developed, deployed, and scaled separately. This approach allows for greater flexibility and scalability, as well as easier maintenance and testing. It also enables different parts of the application to be written in different languages and technologies, and allows for independent deployment and scaling of each service. However, it also requires careful planning and coordination to ensure that the different services work together effectively.\vspace{5mm} \\
Microcontroller development is the process of designing, coding, testing, and debugging software and firmware for microcontrollers, which are small, low-power computer systems that can be integrated into a wide variety of devices and systems.\vspace{5mm} \\
The development process for microcontroller-based systems involves the following steps:
\begin{itemize}
\item Hardware design: This includes selecting and specifying the microcontroller and any other components, such as sensors and actuators, that will be used in the system.
\item Software development: This includes writing the firmware or embedded software that will run on the microcontroller. This step typically involves using a programming language such as C or Assembly and a development environment such as IAR Embedded Workbench or Keil uVision.
\item Testing and debugging: This includes testing the system to ensure that it functions correctly and debugging any issues that are found. This step typically involves using tools such as logic analyzers, oscilloscopes, and in-circuit emulators (ICEs) to test and debug the system.
\item Deployment: Once the system has been tested and debugged, it is ready to be deployed in the final application.
\end{itemize}
There are also development boards that are specifically designed for microcontroller development, these boards include the microcontroller, memory, and peripheral interfaces, and they make the development process easier by providing a ready-made platform for testing and debugging firmware.
\input{tools}
