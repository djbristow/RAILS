\chapter{Introduction}
\gls{rails} is a software model and implementation of an automated system to assist the model railroader achieve realism in the operation of a model railroad. The model then drives the development of hardware and or software.
The system provides, but not limited to the following functions:
\begin{itemize}
  \item planing operating session resulting from the needs of industries to move products from one location to another
  \item simulating rolling stock failures
  \item controlling trains
  \item automating regular scheduled trains 
  \item displaying the rail network and location of trains.
\end{itemize}
In addition, it provides:
\begin{itemize}
  \item model railroad asset tracking and management by organizing the development of assets into projects
  \item rolling stock inventory
  \item reports
\end{itemize} 
The system interacts with several key electronic subsystems to control the physical model railroad environment.
\section{Original Approach}
The original approach that was taken was use a standard software development methodology, starting with the development of requirements through the use of use-cases. The initial client/server design pattern was based on using:
\begin{itemize}
\item \gls{jee}, which is a collection of Java technologies and standards for building enterprise applications. \gls{jee} applications are typically monolithic, meaning that all of the components of the application are packaged together and deployed as a single unit. They can be developed using various Java frameworks such as Spring, \gls{jsf}, and \gls{ejb}, and they are typically deployed to an application server such as Apache Tomcat or Oracle WebLogic.
\item \gls{rdb}, which is a type of database that stores data in the form of related tables. These tables have rows and columns, and each row represents a single record, while each column represents a specific field of data. The tables are related to each other through the use of common fields, known as keys, which are used to link the data in different tables together. This allows for efficient querying and data manipulation. Examples of relational databases include MySQL, SQL Server, DB2, and Oracle.
\end{itemize}
The result would be a web application that would provide multiple users access to the developed system.\vspace{5mm} \\
That approach was undertaken almost two decades ago and based on expertise at hand. Since technology evolved and more options were made available the focus switched from Java to JavaScript and from a relational database to non-relational database. The use cases were still relevant as they speak to the user interactions with the system.
\section{Approach Implemented}
The revised client/server design pattern that is being implemented is based on using (each of which is dicussed in the \ref{technologies} \nameref{technologies} subsection):
\begin{itemize}
\item Node.js see subsubsection \ref{nodejs}
\item Vue.js see subsubsection \ref{vuejs}
\item MongoDB see subsubsection \ref{mongodb}
\end{itemize}
\subsection{Architecture}
Moving from a monolithic \gls{jee} application to a distributed set of components requires a different architecture design pattern. One such pattern is microservices architecture. The microservices architectural style is an evolution of the \gls{soa} architectural style.\vspace{5mm} \\
It is a method of developing software applications in which a large application is built as a collection of small, independent services. These services communicate with each other through APIs, and each service can be developed, deployed, and scaled independently of the others. Microservices are often deployed in containerized environments and use technologies such as Kubernetes to manage and orchestrate the services. Microservices offers several advantages over monolithic architectures such as:
\begin{itemize}
\item Scalability: Each service can be scaled independently, so it's easy to add more resources to a specific service that's experiencing heavy load.
\item Resilience: Because each service is isolated, a failure in one service will not bring down the entire application.
\item Flexibility: Services can be written in different languages, which makes it easy to use the best tool for the job.
\item Ease of Deployment: Since each service can be deployed independently, the deployment process can be simplified.
\end{itemize}
\subsection{Technologies}\label{technologies}
In designing and implementing \gls{rails} several technologies have been added to microservices architectural style that compliment it. They are:
\subsubsection{Docker}
In the context of microservices, containers are used to package the code, libraries, and configuration files needed for a microservice to run as a single, executable unit. This makes it easy to deploy and run microservices in different environments, such as on-premises servers or in the cloud. By packaging all the dependencies for a microservice in a container, it can be guaranteed to run the same way regardless of the environment it's deployed in. This helps to reduce issues caused by differences between development, testing, and production environments. Containers also make it easy to scale up or down the number of instances of a microservice running, and to update or rollback a microservice without affecting other services.\vspace{5mm} \\
Docker is a platform that makes it easy to create, deploy, and run applications in containers. It provides a \gls{cli} and a set of \glspl{api} that make it simple to work with containers. Docker in conjunction with microservices is used to package and deploy each service in its own container. This allows each service to be managed, deployed, and scaled independently of other services. The Docker platform provides a number of tools to help manage and orchestrate the containers that make up a microservice-based application, such as Docker Compose and Docker Swarm.\vspace{5mm} \\
Docker is an open-source platform that enables developers to automate the deployment, scaling, and management of applications using containerization. Containers are lightweight, isolated environments that encapsulate an application and all its dependencies, including libraries, frameworks, and other runtime components. Docker allows the user to package an application into a container image, which can then be run consistently across different environments, such as development, testing, and production.\vspace{5mm} \\
Docker provides the following features:
\begin{itemize}
  \item Docker containers are portable and can run on any system that supports Docker, regardless of the underlying operating system or infrastructure. This eliminates the "works on my machine" problem and ensures consistent behavior across different environments.
  \item Containers provide a high level of isolation, ensuring that applications and their dependencies are encapsulated and do not interfere with each other. This isolation improves security, as well as prevents conflicts between different software components.
  \item Docker containers are lightweight and share the host system's operating system kernel. This means they require fewer resources compared to traditional \glspl{vm}. Multiple containers can run on the same host without significant performance overhead.
  \item Docker makes it easy to scale applications horizontally by running multiple instances of containers across different hosts or a cluster of machines. This enables efficient utilization of resources and helps handle increased workload demands.
  \item Docker allows versioning of container images, making it easier to track changes and roll back to a previous version if needed. This simplifies the deployment and update process, reducing the risk of application downtime.
  \item Docker has a large and active community, resulting in a vast ecosystem of pre-built container images available from Docker Hub and other registries. These images can be easily pulled and used as a base for building and deploying applications, saving development time.
\end{itemize}
For additional information on Docker see the \href{https://www.docker.com/}{official website}.
\subsubsection{Git \& GitHub}
Git is a distributed \gls{vcs} used for tracking changes in source code during software development. It was created by Linus Torvalds, the creator of the Linux operating system, in 2005. Git allows multiple developers to collaborate on a project by providing a mechanism to manage and merge their code changes efficiently.\vspace{5mm} \\
GitHub is a web-based hosting service and collaboration platform for Git repositories. It provides a centralized location where developers can store, manage, and collaborate on their Git repositories. GitHub offers a variety of features and tools that enhance the functionality of Git and facilitate collaboration among developers and teams.\vspace{5mm} \\
Microsoft acquired GitHub in June 2018 in a deal worth \$7.5 billion. Following the acquisition, GitHub continues to operate as an independent platform, maintaining its brand, services, and user base while also benefiting from Microsoft's resources and support.\vspace{5mm} \\
GitHub provides the following features:
\begin{itemize}
  \item GitHub allows users to host their Git repositories on its servers. Developers can create repositories to store their code and version history.
  \item GitHub promotes social collaboration and networking among developers. Users can follow other developers, star and fork repositories, and contribute to open-source projects.
  \item GitHub includes an issue tracking system where users can create, assign, and track issues related to their projects. Issues can be used to report bugs, suggest enhancements, or discuss project-related topics.
  \item GitHub provides features such as wikis, project boards, and discussions to help teams collaborate effectively. Wikis allow for documentation and knowledge sharing, project boards help manage tasks and workflows, and discussions provide a platform for team communication.
  \item GitHub Pages is a feature that enables users to host static websites directly from their repositories. It simplifies the process of publishing and sharing web content.
\end{itemize}
GitHub offers both free and paid plans, with additional features and storage available in the paid tiers. It has become a popular choice for individual developers, open-source projects, and large organizations due to its user-friendly interface, strong community, and extensive features for code collaboration and project management.
\subsubsection{Node.js}\label{nodejs}
Node.js is an open-source, cross-platform JavaScript runtime environment that allows developers to build server-side and network applications. Node.js enables developers to use JavaScript for server-side scripting, allowing them to write server-side code using the same language as client-side code, which is typically executed in web browsers.
Key features of Node.js are:
\begin{itemize}
  \item Node.js is designed to be non-blocking and event-driven. This means that it can handle many simultaneous connections efficiently, making it well-suited for applications with a large number of I/O operations, such as real-time web applications.
  \item Node.js operates on a single-threaded event loop, which handles asynchronous I/O operations. This allows it to handle many connections concurrently without the need for multithreading, making it scalable and efficient.
  \item Node.js comes with a package manager called npm, which is the largest ecosystem of open-source libraries and modules for JavaScript. Developers can easily install, manage, and share packages and dependencies using npm.
  \item Node.js is cross-platform, meaning it can run on various operating systems, including Windows, macOS, and Linux.
  \item Node.js has a vibrant and active community, and its ecosystem is rich with modules and frameworks that simplify the development of web and server applications. Popular frameworks like Express.js make it easier to build web applications with Node.js.
\end{itemize}
Node.js is commonly used to build server-side applications, APIs, and real-time applications. It has gained popularity for its performance, scalability, and the ability to use JavaScript throughout the entire web application stack, from front end to back end.\vspace{5mm} \\
For additional information on Node.js see the \href{https://nodejs.org/en/about}{official website}.
\subsubsection{MongoDB}\label{mongodb}
MongoDB is a popular open-source NoSQL database management system that falls under the category of document-oriented databases. Developed by MongoDB Inc., MongoDB stores data in flexible, JSON-like documents with a dynamic schema. This means that the fields within a document can vary from one document to another, and data can be nested within sub-documents or arrays.\vspace{5mm} \\
Key features of MongoDB include:
\begin{itemize}
  \item MongoDB stores data in BSON (Binary JSON) documents, which are binary representations of JSON-like documents. This flexible schema allows for the storage of data in a way that is more natural for certain types of applications, as it can accommodate changes in data structure over time.
  \item MongoDB is classified as a NoSQL database, which means it does not rely on the traditional relational database management system (RDBMS) model. NoSQL databases are designed to handle large volumes of unstructured or semi-structured data and can provide better performance and scalability for certain use cases.
  \item MongoDB is designed to scale horizontally by adding more servers to a database cluster, allowing it to handle increased load and larger datasets. It supports automatic sharding, a method of distributing data across multiple machines.
  \item MongoDB provides a rich set of query capabilities, allowing developers to perform complex queries on their data. It supports a variety of query operators, indexing, and aggregation frameworks.
  \item MongoDB is known for its high performance, especially for read and write-intensive applications. It uses memory-mapped files for storage, which can lead to faster read and write operations.
  \item MongoDB supports the creation of indexes on fields to improve query performance. Indexes can be created on single fields or compound indexes on multiple fields.
  \item MongoDB has a large and active community, and it is supported by a rich ecosystem of tools and libraries. It also provides official drivers for a variety of programming languages.
\end{itemize}
MongoDB is commonly used in a range of applications, including content management systems, real-time big data analytics, mobile applications, and more. Its flexibility, scalability, and ease of use make it a popular choice for developers working on projects with evolving or complex data structures.\vspace{5mm} \\
For additional information on MongoDB see the \href{https://www.mongodb.com/}{official website}.
\subsubsection{Vue.js}\label{vuejs}
Vue.js, commonly referred to as Vue, is a progressive JavaScript framework used for building user interfaces. It is designed from the ground up to be incrementally adoptable, meaning that it can be easily integrated into existing projects and other libraries. Vue.js is often used for developing single-page applications (SPAs) where dynamic, responsive user interfaces are crucial.\vspace{5mm} \\
Key features of Vue.js include:
\begin{itemize}
  \item Vue.js uses a declarative approach to describe the structure and behavior of the UI. Developers can use simple template syntax to bind data to the DOM (Document Object Model) and let Vue.js handle the underlying manipulations.
  \item Vue.js promotes a modular and reusable architecture through components. Components encapsulate both the structure (HTML), behavior (JavaScript), and style (CSS) of a part of the UI. Components can be composed and reused throughout the application.
  \item Vue.js provides a reactive data-binding system. When the underlying data changes, the associated DOM updates automatically, and vice versa. This allows developers to build dynamic and responsive applications without directly manipulating the DOM.
  \item Vue.js includes a set of built-in directives that enable developers to add functionality to the DOM elements. For example, the `v-if` directive is used for conditional rendering, and `v-for` is used for rendering lists.
  \item Vue Router is the official routing library for Vue.js, allowing developers to build single-page applications with navigation. It enables the creation of navigation between different views or components in a Vue.js application.
  \item Pinia is the state management library for Vue.js applications. It provides a centralized state management pattern, helping manage the state of the application in a predictable and maintainable way, especially in larger applications.
  \item Vue CLI (Command Line Interface) is a tool for scaffolding and managing Vue.js projects. It helps developers set up a new project with a sensible default configuration, manage dependencies, and build production-ready applications.
\end{itemize}
Vue.js is known for its simplicity and ease of integration, making it a popular choice for both beginners and experienced developers. It can be used for building small to large-scale applications and has a growing community and ecosystem of libraries and tools. Vue.js is often compared to other JavaScript frameworks like React and Angular, and its flexible and progressive nature makes it an attractive option for a variety of projects.\vspace{5mm} \\
For more information about Vue.js, visit the \href{https://vuejs.org/}{official website}.
\subsubsection{IoT}
\gls{iot} refers to the network of physical devices, vehicles, buildings, and other items embedded with electronics, software, sensors, and connectivity which enables these objects to connect and exchange data.
\subsubsection{MQTT}
\gls{mqtt} is a lightweight publish-subscribe messaging protocol that is commonly used for communication in \gls{iot} systems. It enables devices to send and receive messages over a network in a decentralized and efficient way. \gls{mqtt} is often used in \gls{iot} because it is lightweight and requires minimal network bandwidth, making it well-suited for use on resource-constrained devices and low-bandwidth networks. Equally as important there a multiple implementations of the open source client software that are available for microcontrollers such as TI-Tiva, Arduino and Raspberry PI. The following are the high level features:
\begin{itemize}
\item Publish/subscribe: The \gls{mqtt} protocol is based on the principle of publishing messages and subscribing to topics, which is typically referred to as a publish/subscribe model or sometimes abbreviated to pub/sub. Clients can subscribe to topics that are relevant to them. Then those clients only receive messages that are published to those topics. Alternatively, clients can publish messages to topics, which in turn makes them available to all subscribers of those topics.
\item Quality of service levels: \gls{mqtt} defines three \gls{qos} levels for message delivery, with each level providing a higher level of assurance the message gets delivered. However higher \gls{qos} levels are likely to consume more network bandwidth or subject the message to delays.
\item Retained messages: With \gls{mqtt}, the server keeps the message even after sending it to all current subscribers. If a new subscription is submitted for the same topic, any retained messages are then sent to the new subscribing client.
\item Clean sessions and durable connections: When an \gls{mqtt} client connects to the server, it sets the clean session flag. If the flag is set to true, all of the client’s subscriptions are removed when it disconnects from the server. If the flag is set to false, the connection is treated as durable, and the client’s subscriptions remain in effect after any disconnection. In this event, subsequent messages that arrive carrying a high \gls{qos} designation are stored for delivery after the connection is reestablished. Using the clean session flag is optional.
\item Wills: When a client connects to a server, it can inform the server that it has a will , or a message, that should be published to a specific topic or topics in the event of an unexpected disconnection. A will is particularly useful in alarm or security settings where system managers must know immediately when a remote sensor has lost contact with the network.
\end{itemize}
A detailed explantion of the basics of MQTT can be found in the \href{https://www.hivemq.com/mqtt-essentials/}{MQTT Essentials} guide.
\subsubsection{NGINX}
NGINX is an HTTP web server, reverse proxy, content cache, load balancer, TCP/UDP proxy server, and mail proxy server.
\begin{itemize}
\item As an HTTP Web Server it serves web pages and static content (HTML, CSS, JS, images, etc.) At its core, NGINX can act like Apache or any other web server: it receives HTTP requests from browsers and responds with web content. It’s highly efficient at serving static files and is widely used to host websites.
\item As a Reverse Proxy it forwards client requests to backend servers and return their responses. NGINX can sit in front of app servers (like Node.js, Python Flask, etc.), forwarding requests and responses without the client knowing the actual backend architecture. It helps with load distribution, SSL termination, security, and scalability.
\item As a Content Cache it caches responses to reduce backend load and speed up responses. NGINX can store (cache) responses from the backend temporarily, so if the same request comes again, NGINX serves it directly without querying the backend server again.
\item As a Load Balancer it distributes incoming requests across multiple backend servers. NGINX can balance traffic across several servers to improve performance, availability, and reliability. It supports round-robin, least connections, and IP-hash load balancing strategies.
\item As a TCP/UDP Proxy Server it proxies raw TCP or UDP traffic, such as for database or game servers. NGINX (specifically NGINX Plus or with stream module) can handle non-HTTP protocols. This is useful for proxying MySQL, Redis, or other services over raw TCP/UDP.
\item As a Mail Proxy Server it proxies SMTP, IMAP, or POP3 mail traffic. NGINX can act as a gateway for email protocols, allowing for routing and authentication before forwarding to mail servers. This is often used in larger-scale mail systems.
\end{itemize}
For more information about Open Source NGINX, visit the \href{https://nginx.org/en/}{official website}.
\subsubsection{Microcontoller}
A microcontroller is a small computer on a single integrated circuit that contains a processor core, memory, and programmable input/output peripherals. It is designed to control a specific function or set of functions within a larger system. Microcontrollers are used in a wide range of electronic devices and appliances, including automobiles, appliances, and consumer electronics.
There are multiple advantages to using microcontrollers in electronic devices and systems:
\begin{itemize}
\item Cost-effective: Microcontrollers are relatively inexpensive and can be used to control a wide range of functions in a single device, reducing the overall cost of the system.
\item Low power consumption: Microcontrollers are designed to consume minimal power, which makes them well-suited for use in battery-powered or low-power applications.
\item Compact size: Microcontrollers are small in size, which allows them to be used in tight spaces or portable devices.
\item Flexibility: Microcontrollers can be easily programmed to perform a wide range of functions, making them highly versatile and adaptable to different applications.
\item Easy to interface with other devices: Microcontrollers have a variety of \gls{io} ports, which makes it easy to interface them with other devices such as sensors, actuators, and communication interfaces.
\item Real-time performance: Microcontrollers can perform a variety of tasks concurrently, and also can handle real-time events which allows them to respond quickly to changing conditions in the system.
\item Robustness: Microcontrollers are designed to operate in a wide range of environments, and can be used in harsh conditions like extreme temperatures and high levels of radiation.
\end{itemize}
In the context of the \gls{iot}, microcontrollers are used to collect data from sensors and control actuators, and to process and transmit that data over a network.
\section{Software Development}
Microservices development is a software development approach in which a software application is broken down into smaller, independent services that can be developed, deployed, and scaled separately. This approach allows for greater flexibility and scalability, as well as easier maintenance and testing. It also enables different parts of the application to be written in different languages and technologies, and allows for independent deployment and scaling of each service. However, it also requires careful planning and coordination to ensure that the different services work together effectively.\vspace{5mm} \\
Microcontroller development is the process of designing, coding, testing, and debugging software and firmware for microcontrollers, which are small, low-power computer systems that can be integrated into a wide variety of devices and systems.\vspace{5mm} \\
The development process for microcontroller-based systems involves the following steps:
\begin{itemize}
\item Hardware design: This includes selecting and specifying the microcontroller and any other components, such as sensors and actuators, that will be used in the system.
\item Software development: This includes writing the firmware or embedded software that will run on the microcontroller. This step typically involves using a programming language such as C or Assembly and a development environment such as IAR Embedded Workbench or Keil uVision.
\item Testing and debugging: This includes testing the system to ensure that it functions correctly and debugging any issues that are found. This step typically involves using tools such as logic analyzers, oscilloscopes, and \glspl{ice} to test and debug the system.
\item Deployment: Once the system has been tested and debugged, it is ready to be deployed in the final application.
\end{itemize}
There are also development boards that are specifically designed for microcontroller development, these boards include the microcontroller, memory, and peripheral interfaces, and they make the development process easier by providing a ready-made platform for testing and debugging firmware.
\input{tools}
